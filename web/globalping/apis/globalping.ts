function getApiEndpoint(): string {
  return (
    process.env.NEXT_PUBLIC_API_ENDPOINT ||
    "https://globalping-api.netneighbor.me"
  );
}

export async function getCurrentPingers(): Promise<string[]> {
  return fetch(`${getApiEndpoint()}/conns`)
    .then((res) => res.json())
    .then((data) => {
      const nodes: string[] = [];
      if (typeof data === "object") {
        for (const key in data) {
          const node = data[key];
          if (typeof node === "object") {
            if (
              node["attributes"] &&
              node["attributes"]["NodeName"] &&
              node["attributes"]["CapabilityPing"]
            ) {
              nodes.push(String(node["attributes"]["NodeName"]));
            }
          }
        }
      }
      return nodes;
    })
    .catch((err) => {
      console.error("Failed to get current pingers:", err);
      return [];
    });
}

// A stream source is said to adaptable if it is convertible to a PingSample stream.
export type PingSample = {
  // the node name where the icmp echo request is originated from, it's mostly just a label, not something that is pingable
  from: string;

  // the destination of the icmp echo request, in dns un-resolved form
  target: string;

  // in the unit of milliseconds
  latencyMs: number;

  // the ttl of the sent packet
  ttl?: number | null;

  // the seq of the sent packet
  seq?: number | null;

  // the address of the peer, could be the original destination, or some middlebox halfway
  peer?: string;

  // the rdns of the peer, not necessarily available
  peerRdns?: string;
};

export function generateFakePingSampleStream(
  sources: string[],
  targets: string[]
): ReadableStream<PingSample> {
  let intervalId: ReturnType<typeof setInterval> | null = null;

  return new ReadableStream<PingSample>({
    start(controller) {
      console.log("[dbg] start stream", sources, targets);

      intervalId = setInterval(() => {
        console.log("[dbg] interval invoked");

        // Generate all combinations of sources Ã— targets
        for (const source of sources) {
          for (const target of targets) {
            // Generate a fake latency between 10ms and 300ms
            const latencyMs = Math.floor(Math.random() * 290) + 10;

            const sample: PingSample = {
              from: source,
              target: target,
              latencyMs: latencyMs,
            };

            console.log("[dbg] enqueueing sample:", sample);

            controller.enqueue(sample);
          }
        }
      }, 150); // Emit every 1 second
    },
    cancel() {
      // Clear the interval when the stream is cancelled
      if (intervalId !== null) {
        clearInterval(intervalId);
        intervalId = null;
      }
    },
  });
}

export type ISO8601Timestamp = string;

type RawPingEventICMPReply = {
  ICMPTypeV4?: number;
  ICMPTypeV6?: number;
  ID?: number;
  Peer?: string;
  PeerRDNS?: string[];
  ReceivedAt?: ISO8601Timestamp;

  // Seq of the reply packet
  Seq?: number;
  // size of icmp, without the ip(v4/v6) header
  Size?: number;
  // TTl of the reply packet
  TTL?: number;
}

type RawPingEventData = {
  RTTMilliSecs?: number[];
  RTTNanoSecs?: number[];
  Raw?: RawPingEventICMPReply[];
  ReceivedAt?: ISO8601Timestamp[];
  SentAt?: ISO8601Timestamp;

  // Seq of the sent packet
  Seq?: number;

  // TTL of the sent packet
  TTL?: number;
}

type RawPingEventMetadata = {
  from?: string;
  target?: string;
}

// Raw event returned by the API
type RawPingEvent = {
  data?: RawPingEventData;
  metadata?: RawPingEventMetadata;
};

type TokenObject = {
  content: string;
};

// Generated by: deepseek
class LineTokenizer extends TransformStream<string, TokenObject> {
  constructor() {
    let buffer = "";

    super({
      transform(
        chunk: string,
        controller: TransformStreamDefaultController<TokenObject>
      ) {
        buffer += chunk;

        let newlineIndex;
        while ((newlineIndex = buffer.indexOf("\n")) !== -1) {
          const line = buffer.slice(0, newlineIndex);

          const cleanLine = line.endsWith("\r") ? line.slice(0, -1) : line;

          controller.enqueue({ content: cleanLine });

          buffer = buffer.slice(newlineIndex + 1);
        }
      },

      flush(controller: TransformStreamDefaultController<TokenObject>) {
        if (buffer) {
          const cleanLine = buffer.endsWith("\r")
            ? buffer.slice(0, -1)
            : buffer;
          controller.enqueue({ content: cleanLine });
        }
      },
    });
  }
}

class JSONLineDecoder extends TransformStream<TokenObject, unknown> {
  constructor() {
    super({
      transform(
        chunk: TokenObject,
        controller: TransformStreamDefaultController<unknown>
      ) {
        try {
          const unknownObj = JSON.parse(chunk.content);
          controller.enqueue(unknownObj);
        } catch (err) {
          console.error("Failed to parse JSON line:", err);
        }
      },
    });
  }
}

class PingEventAdapter extends TransformStream<RawPingEvent, PingSample> {
  constructor() {
    super({
      transform(
        chunk: RawPingEvent,
        controller: TransformStreamDefaultController<PingSample>
      ) {
        const maybeSample = pingSampleFromEvent(chunk);
        if (maybeSample) {
          controller.enqueue(maybeSample);
        }
      },
    });
  }
}

function pingSampleFromEvent(event: RawPingEvent): PingSample | undefined {
  const from = event.metadata?.from || "";
  const target = event.metadata?.target || "";
  const latencies = event.data?.RTTNanoSecs
  const latencyMs = latencies && latencies.length > 0 ? latencies[latencies.length-1]/1000000 : -1;
  if (latencyMs < 0) {
    return undefined;
  }
  const ttl = event.data?.TTL;
  const seq = event.data?.Seq;
  const raws = event.data?.Raw;
  const peer = raws && raws.length > 0 ? raws[raws.length-1].Peer : undefined;
  const peerRdns = raws && raws.length > 0 ? raws[raws.length-1].PeerRDNS : undefined;
  const peerRdnsLast = peerRdns && peerRdns.length > 0 ? peerRdns[peerRdns.length-1] : undefined;

  return {
    from: from,
    target: target,
    latencyMs: latencyMs,
    ttl: ttl,
    seq: seq,
    peer: peer,
    peerRdns: peerRdnsLast,
  }
}

function convertRawStreamToPingSampleStream(
  rawStream: ReadableStream<any> | undefined | null
): ReadableStream<PingSample> | undefined | null {
  return;
}

export function generatePingSampleStream(
  sources: string[],
  targets: string[],
  count: number,
  intervalMs: number,
  timeoutSecs: number
): ReadableStream<PingSample> {
  const payload = {
    from: sources,
    targets: targets,
    count: count,
    interval: intervalMs,
    timeout: timeoutSecs,
  };
  const payloadJson = JSON.stringify(payload);

  const headers = new Headers();
  headers.set("Content-Type", "application/json");

  let controlscope: {
    rawStream?: ReadableStream<Uint8Array<ArrayBuffer>> | null;
    sampleStream?: ReadableStream<PingSample> | null;
    reader?: ReadableStreamDefaultReader<PingSample> | null;
    stopped?: boolean;
  } = {};

  return new ReadableStream<PingSample>({
    start(controller) {
      fetch(`${getApiEndpoint()}/ping-task`, {
        method: "POST",
        headers: headers,
        body: payloadJson,
      })
        .then((res) => res.body)
        .then((rawStream) => {
          controlscope.rawStream = rawStream;
          return rawStream
            ?.pipeThrough(new TextDecoderStream())
            .pipeThrough(new LineTokenizer())
            .pipeThrough(new JSONLineDecoder())
            .pipeThrough(new PingEventAdapter());
        })
        .then((maybeSampleStream) => {
          controlscope.sampleStream = maybeSampleStream;
          if (maybeSampleStream) {
            const reader = maybeSampleStream.getReader();
            controlscope.reader = reader;
            function push() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  return;
                }
                if (value && !controlscope.stopped) {
                  console.log("[dbg] enqueueing sample:", value);
                  controller.enqueue(value);
                }
                push();
              });
            }
            push();
          }
        });
    },
    cancel() {
      console.log("[dbg] cancel stream", sources, targets);
      controlscope.stopped = true;
      controlscope.reader
        ?.cancel()
        .then(() => {
          console.log("[dbg] reader cancelled");
        })
        .catch((err) => {
          console.error("[dbg] failed to cancel reader:", err);
        });
    },
  });
}

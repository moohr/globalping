function getApiEndpoint(): string {
  return (
    process.env.NEXT_PUBLIC_API_ENDPOINT ||
    "https://globalping-api.netneighbor.me"
  );
}

export async function getCurrentPingers(): Promise<string[]> {
  return fetch(`${getApiEndpoint()}/conns`)
    .then((res) => res.json())
    .then((data) => {
      const nodes: string[] = [];
      if (typeof data === "object") {
        for (const key in data) {
          const node = data[key];
          if (typeof node === "object") {
            if (
              node["attributes"] &&
              node["attributes"]["NodeName"] &&
              node["attributes"]["CapabilityPing"]
            ) {
              nodes.push(String(node["attributes"]["NodeName"]));
            }
          }
        }
      }
      return nodes;
    })
    .catch((err) => {
      console.error("Failed to get current pingers:", err);
      return [];
    });
}

export type PingSample = {
  from: string;
  target: string;

  // in the unit of milliseconds
  latencyMs: number;
};

export function generateFakePingSampleStream(
  sources: string[],
  targets: string[]
): ReadableStream<PingSample> {
  let intervalId: ReturnType<typeof setInterval> | null = null;

  return new ReadableStream<PingSample>({
    start(controller) {
      console.log("[dbg] start stream", sources, targets);

      intervalId = setInterval(() => {
        console.log("[dbg] interval invoked");

        // Generate all combinations of sources Ã— targets
        for (const source of sources) {
          for (const target of targets) {
            // Generate a fake latency between 10ms and 300ms
            const latencyMs = Math.floor(Math.random() * 290) + 10;

            const sample: PingSample = {
              from: source,
              target: target,
              latencyMs: latencyMs,
            };

            console.log("[dbg] enqueueing sample:", sample);

            controller.enqueue(sample);
          }
        }
      }, 150); // Emit every 1 second
    },
    cancel() {
      // Clear the interval when the stream is cancelled
      if (intervalId !== null) {
        clearInterval(intervalId);
        intervalId = null;
      }
    },
  });
}

type PingEvent = {
  type?: "pkt_recv" | "ping_stats";
  data?: {
    target?: string;
    rtt?: number;
    min_rtt?: number;
    max_rtt?: number;
    avg_rtt?: number;
  };
  metadata?: {
    from?: string;
    // target could also be here, not just in the data field
    target?: string;
  };
};

type TokenObject = {
  content: string;
};

// Generated by: deepseek
class LineTokenizer extends TransformStream<string, TokenObject> {
  constructor() {
    let buffer = "";

    super({
      transform(
        chunk: string,
        controller: TransformStreamDefaultController<TokenObject>
      ) {
        buffer += chunk;

        let newlineIndex;
        while ((newlineIndex = buffer.indexOf("\n")) !== -1) {
          const line = buffer.slice(0, newlineIndex);

          const cleanLine = line.endsWith("\r") ? line.slice(0, -1) : line;

          console.log("[dbg] enqueueing line:", cleanLine);
          controller.enqueue({ content: cleanLine });

          buffer = buffer.slice(newlineIndex + 1);
        }
      },

      flush(controller: TransformStreamDefaultController<TokenObject>) {
        if (buffer) {
          const cleanLine = buffer.endsWith("\r")
            ? buffer.slice(0, -1)
            : buffer;
          controller.enqueue({ content: cleanLine });
        }
      },
    });
  }
}

class JSONLineDecoder extends TransformStream<TokenObject, unknown> {
  constructor() {
    super({
      transform(
        chunk: TokenObject,
        controller: TransformStreamDefaultController<unknown>
      ) {
        try {
          const unknownObj = JSON.parse(chunk.content);
          controller.enqueue(unknownObj);
        } catch (err) {
          console.error("Failed to parse JSON line:", err);
        }
      },
    });
  }
}

class PingEventAdapter extends TransformStream<PingEvent, PingSample> {
  constructor() {
    super({
      transform(
        chunk: PingEvent,
        controller: TransformStreamDefaultController<PingSample>
      ) {
        const maybeSample = pingSampleFromEvent(chunk);
        if (maybeSample) {
          controller.enqueue(maybeSample);
        }
      },
    });
  }
}

function pingSampleFromEvent(event: PingEvent): PingSample | undefined {
  if (event.type === "pkt_recv") {
    return {
      from: event.metadata?.from || "",
      target: event.data?.target || event.metadata?.target || "",
      latencyMs: event.data?.rtt ?? 0,
    };
  } else if (event.type === "ping_stats") {
    return {
      from: event.metadata?.from || "",
      target: event.data?.target || event.metadata?.target || "",
      latencyMs: event.data?.rtt ?? event.data?.avg_rtt ?? 0,
    };
  }
}

function convertRawStreamToPingSampleStream(
  rawStream: ReadableStream<any> | undefined | null
): ReadableStream<PingSample> | undefined | null {
  return;
}

export function generatePingSampleStream(
  sources: string[],
  targets: string[],
  count: number,
  intervalMs: number,
  timeoutSecs: number
): ReadableStream<PingSample> {
  const payload = {
    from: sources,
    targets: targets,
    count: count,
    interval: intervalMs,
    timeout: timeoutSecs,
  };
  const payloadJson = JSON.stringify(payload);

  const headers = new Headers();
  headers.set("Content-Type", "application/json");

  let controlscope: {
    rawStream?: ReadableStream<Uint8Array<ArrayBuffer>> | null;
    sampleStream?: ReadableStream<PingSample> | null;
    reader?: ReadableStreamDefaultReader<PingSample> | null;
    stopped?: boolean;
  } = {};

  return new ReadableStream<PingSample>({
    start(controller) {
      fetch(`${getApiEndpoint()}/ping-task`, {
        method: "POST",
        headers: headers,
        body: payloadJson,
      })
        .then((res) => res.body)
        .then((rawStream) => {
          controlscope.rawStream = rawStream;
          return rawStream
            ?.pipeThrough(new TextDecoderStream())
            .pipeThrough(new LineTokenizer())
            .pipeThrough(new JSONLineDecoder())
            .pipeThrough(new PingEventAdapter());
        })
        .then((maybeSampleStream) => {
          controlscope.sampleStream = maybeSampleStream;
          if (maybeSampleStream) {
            const reader = maybeSampleStream.getReader();
            controlscope.reader = reader;
            function push() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  return;
                }
                if (value && !controlscope.stopped) {
                  console.log("[dbg] enqueueing sample:", value);
                  controller.enqueue(value);
                }
                push();
              });
            }
            push();
          }
        });
    },
    cancel() {
      console.log("[dbg] cancel stream", sources, targets);
      controlscope.stopped = true;
      controlscope.reader
        ?.cancel()
        .then(() => {
          console.log("[dbg] reader cancelled");
        })
        .catch((err) => {
          console.error("[dbg] failed to cancel reader:", err);
        });
    },
  });
}

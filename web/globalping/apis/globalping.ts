function getApiEndpoint(): string {
  return (
    process.env.NEXT_PUBLIC_API_ENDPOINT ||
    "https://globalping-api.netneighbor.me"
  );
}

export async function getCurrentPingers(): Promise<string[]> {
  return fetch(`${getApiEndpoint()}/conns`)
    .then((res) => res.json())
    .then((data) => {
      const nodes: string[] = [];
      if (typeof data === "object") {
        for (const key in data) {
          const node = data[key];
          if (typeof node === "object") {
            if (
              node["attributes"] &&
              node["attributes"]["NodeName"] &&
              node["attributes"]["CapabilityPing"]
            ) {
              nodes.push(String(node["attributes"]["NodeName"]));
            }
          }
        }
      }
      return nodes;
    })
    .catch((err) => {
      console.error("Failed to get current pingers:", err);
      return [];
    });
}

export type PingSample = {
  from: string;
  target: string;

  // in the unit of milliseconds
  latencyMs: number;
};

export function generateFakePingSampleStream(
  sources: string[],
  targets: string[]
): ReadableStream<PingSample> {
  let intervalId: ReturnType<typeof setInterval> | null = null;

  return new ReadableStream<PingSample>({
    start(controller) {
      console.log("[dbg] start stream", sources, targets);

      intervalId = setInterval(() => {
        console.log("[dbg] interval invoked");

        // Generate all combinations of sources × targets
        for (const source of sources) {
          for (const target of targets) {
            // Generate a fake latency between 10ms and 300ms
            const latencyMs = Math.floor(Math.random() * 290) + 10;

            const sample: PingSample = {
              from: source,
              target: target,
              latencyMs: latencyMs,
            };

            console.log("[dbg] enqueueing sample:", sample);

            controller.enqueue(sample);
          }
        }
      }, 150); // Emit every 1 second
    },
    cancel() {
      // Clear the interval when the stream is cancelled
      if (intervalId !== null) {
        clearInterval(intervalId);
        intervalId = null;
      }
    },
  });
}

type PingEvent = {
  type?: "pkt_recv" | "ping_stats";
  data?: {
    target?: string;
    rtt?: number;
    min_rtt?: number;
    max_rtt?: number;
    avg_rtt?: number;
  };
  metadata?: {
    from?: string;
  };
};

type TokenObject = {
  content: string;
};

// Generated by: deepseek
class LineTokenizer extends TransformStream<string, TokenObject> {
  constructor() {
    let buffer = "";

    super({
      transform(
        chunk: string,
        controller: TransformStreamDefaultController<TokenObject>
      ) {
        // 将新数据添加到缓冲区
        buffer += chunk;

        // 查找并分割所有完整的行
        let newlineIndex;
        while ((newlineIndex = buffer.indexOf("\n")) !== -1) {
          // 提取一行（不包括换行符）
          const line = buffer.slice(0, newlineIndex);

          // 处理可能的回车符（Windows 风格的 \r\n）
          const cleanLine = line.endsWith("\r") ? line.slice(0, -1) : line;

          // 发送行
          console.log("[dbg] enqueueing line:", cleanLine);
          controller.enqueue({ content: cleanLine });

          // 从缓冲区移除已处理的行
          buffer = buffer.slice(newlineIndex + 1);
        }
      },

      flush(controller: TransformStreamDefaultController<TokenObject>) {
        // 发送缓冲区中剩余的数据（最后一行，如果没有换行符）
        if (buffer) {
          const cleanLine = buffer.endsWith("\r")
            ? buffer.slice(0, -1)
            : buffer;
          controller.enqueue({ content: cleanLine });
        }
      },
    });
  }
}

class JSONLineDecoder extends TransformStream<TokenObject, unknown> {
  constructor() {
    super({
      transform(
        chunk: TokenObject,
        controller: TransformStreamDefaultController<unknown>
      ) {
        try {
          const unknownObj = JSON.parse(chunk.content);
          controller.enqueue(unknownObj);
        } catch (err) {
          console.error("Failed to parse JSON line:", err);
        }
      },
    });
  }
}

class PingEventAdapter extends TransformStream<PingEvent, PingSample> {
  constructor() {
    super({
      transform(
        chunk: PingEvent,
        controller: TransformStreamDefaultController<PingSample>
      ) {
        const maybeSample = pingSampleFromEvent(chunk);
        if (maybeSample) {
          controller.enqueue(maybeSample);
        }
      },
    });
  }
}

function pingSampleFromEvent(event: PingEvent): PingSample | undefined {
  if (event.type === "pkt_recv") {
    return {
      from: event.metadata?.from || "",
      target: event.data?.target || "",
      latencyMs: event.data?.rtt ?? 0,
    };
  } else if (event.type === "ping_stats") {
    return {
      from: event.metadata?.from || "",
      target: event.data?.target || "",
      latencyMs: event.data?.rtt ?? event.data?.avg_rtt ?? 0,
    };
  }
}

export function generatePingSampleStream(
  sources: string[],
  targets: string[],
  count: number,
  intervalMs: number
): ReadableStream<PingSample> {
  const payload = {
    from: sources,
    targets: targets,
    count: count,
    interval: intervalMs,
  };
  const payloadJson = JSON.stringify(payload);

  const headers = new Headers();
  headers.set("Content-Type", "application/json");

  return new ReadableStream<PingSample>({
    start(controller) {
      fetch(`${getApiEndpoint()}/ping-task`, {
        method: "POST",
        headers: headers,
        body: payloadJson,
      })
        .then((res) => res.body)
        .then((bodyStream) => bodyStream?.pipeThrough(new TextDecoderStream()))
        .then((maybeTextStream) =>
          maybeTextStream?.pipeThrough(new LineTokenizer())
        )
        .then((maybeLineStream) =>
          maybeLineStream?.pipeThrough(new JSONLineDecoder())
        )
        .then((maybeObjectStream) =>
          maybeObjectStream?.pipeThrough(new PingEventAdapter())
        )
        .then((maybeSampleStream) => {
          if (maybeSampleStream) {
            const reader = maybeSampleStream.getReader();
            function push() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  return;
                }
              });
            }
            push();
          }
        });
    },
    cancel() {
      console.log("[dbg] cancel stream", sources, targets);
    },
  });
}

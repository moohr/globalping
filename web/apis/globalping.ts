import { ExactLocation } from "./types";

function getApiEndpoint(): string {
  return (
    process.env.NEXT_PUBLIC_API_ENDPOINT ||
    "https://globalping-api.netneighbor.me"
  );
}

export async function getCurrentPingers(): Promise<string[]> {
  return fetch(`${getApiEndpoint()}/conns`)
    .then((res) => res.json())
    .then((data) => {
      const nodes: string[] = [];
      if (typeof data === "object") {
        for (const key in data) {
          const node = data[key];
          if (typeof node === "object") {
            if (
              node["attributes"] &&
              node["attributes"]["NodeName"] &&
              node["attributes"]["CapabilityPing"]
            ) {
              nodes.push(String(node["attributes"]["NodeName"]));
            }
          }
        }
      }
      return nodes;
    })
    .catch((err) => {
      console.error("Failed to get current pingers:", err);
      return [];
    });
}

// A stream source is said to adaptable if it is convertible to a PingSample stream.
export type PingSample = {
  // the node name where the icmp echo request is originated from, it's mostly just a label, not something that is pingable
  from: string;

  // the destination of the icmp echo request, in dns un-resolved form
  target: string;

  // in the unit of milliseconds
  latencyMs?: number;

  // the ttl of the sent packet, ttl must be present, even in the case of timeout
  ttl: number;

  // the seq of the sent packet, seq must be present, even in the case of timeout
  seq: number;

  // the address of the peer, could be the original destination, or some middlebox halfway
  peer?: string;

  // the rdns of the peer, not necessarily available
  peerRdns?: string;

  peerASN?: string;

  peerLocation?: string;

  peerISP?: string;

  peerExactLocation?: ExactLocation;

  lastHop?: boolean;
};

export function generateFakePingSampleStream(
  sources: string[],
  targets: string[]
): ReadableStream<PingSample> {
  let intervalId: ReturnType<typeof setInterval> | null = null;

  return new ReadableStream<PingSample>({
    start(controller) {
      console.log("[dbg] start stream", sources, targets);

      intervalId = setInterval(() => {
        console.log("[dbg] interval invoked");

        let seq = 0;
        // Generate all combinations of sources Ã— targets
        for (const source of sources) {
          for (const target of targets) {
            // Generate a fake latency between 10ms and 300ms
            const latencyMs = Math.floor(Math.random() * 290) + 10;

            const sample: PingSample = {
              from: source,
              target: target,
              latencyMs: latencyMs,
              ttl: 64,
              seq: seq,
            };
            seq++;

            controller.enqueue(sample);
          }
        }
      }, 150); // Emit every 1 second
    },
    cancel() {
      // Clear the interval when the stream is cancelled
      if (intervalId !== null) {
        clearInterval(intervalId);
        intervalId = null;
      }
    },
  });
}

export type ISO8601Timestamp = string;

type RawPingEventICMPReply = {
  ICMPTypeV4?: number;
  ICMPTypeV6?: number;
  ID?: number;
  Peer?: string;
  PeerRDNS?: string[];
  PeerASN?: string;
  PeerLocation?: string;
  PeerISP?: string;
  PeerExactLocation?: ExactLocation;

  ReceivedAt?: ISO8601Timestamp;

  // Seq of the reply packet
  Seq?: number;
  // size of icmp, without the ip(v4/v6) header
  Size?: number;
  // TTl of the reply packet
  TTL?: number;

  LastHop?: boolean;
};

type RawPingEventData = {
  RTTMilliSecs?: number[];
  RTTNanoSecs?: number[];
  Raw?: RawPingEventICMPReply[];
  ReceivedAt?: ISO8601Timestamp[];
  SentAt?: ISO8601Timestamp;

  // Seq of the sent packet
  Seq?: number;

  // TTL of the sent packet
  TTL?: number;
};

type RawPingEventMetadata = {
  from?: string;
  target?: string;
};

// Raw event returned by the API
type RawPingEvent = {
  data?: RawPingEventData;
  metadata?: RawPingEventMetadata;
};

type TokenObject = {
  content: string;
};

// Generated by: deepseek
class LineTokenizer extends TransformStream<string, TokenObject> {
  constructor() {
    let buffer = "";

    super({
      transform(
        chunk: string,
        controller: TransformStreamDefaultController<TokenObject>
      ) {
        buffer += chunk;

        let newlineIndex;
        while ((newlineIndex = buffer.indexOf("\n")) !== -1) {
          const line = buffer.slice(0, newlineIndex);

          const cleanLine = line.endsWith("\r") ? line.slice(0, -1) : line;

          controller.enqueue({ content: cleanLine });

          buffer = buffer.slice(newlineIndex + 1);
        }
      },

      flush(controller: TransformStreamDefaultController<TokenObject>) {
        if (buffer) {
          const cleanLine = buffer.endsWith("\r")
            ? buffer.slice(0, -1)
            : buffer;
          controller.enqueue({ content: cleanLine });
        }
      },
    });
  }
}

class JSONLineDecoder extends TransformStream<TokenObject, unknown> {
  constructor() {
    super({
      transform(
        chunk: TokenObject,
        controller: TransformStreamDefaultController<unknown>
      ) {
        try {
          const unknownObj = JSON.parse(chunk.content);
          controller.enqueue(unknownObj);
        } catch (err) {
          console.error("Failed to parse JSON line:", err);
        }
      },
    });
  }
}

class PingEventAdapter extends TransformStream<RawPingEvent, PingSample> {
  constructor() {
    super({
      transform(
        chunk: RawPingEvent,
        controller: TransformStreamDefaultController<PingSample>
      ) {
        const maybeSample = pingSampleFromEvent(chunk);
        if (maybeSample) {
          controller.enqueue(maybeSample);
        }
      },
    });
  }
}

function pingSampleFromEvent(event: RawPingEvent): PingSample | undefined {
  console.log('[dbg] raw ping sample TTL=', event.data?.TTL);

  const from = event.metadata?.from || "";
  const target = event.metadata?.target || "";

  let latencyMs: number | undefined = undefined;
  const latencies = event.data?.RTTNanoSecs;
  if (latencies && latencies.length > 0) {
    latencyMs = latencies[latencies.length - 1] / 1000000;
  }
  // if you can obtain some basic information from a RawPingEvent, say, from, target, ttl, seq, etc.,
  // but no rtt, then it's probably a timeout event, when rendering as traceroute display, perhaps mark it as triple asterisk?

  const ttl = event.data?.TTL;
  const seq = event.data?.Seq;
  if (ttl === undefined || ttl === null || seq === undefined || seq === null) {
    console.log("skipping invalid sample, missing ttl or seq (or both)", event);
    return;
  }

  const raws = event.data?.Raw;
  const peer = raws && raws.length > 0 ? raws[raws.length - 1].Peer : undefined;
  const peerRdns =
    raws && raws.length > 0 ? raws[raws.length - 1].PeerRDNS : undefined;
  const peerRdnsLast =
    peerRdns && peerRdns.length > 0 ? peerRdns[peerRdns.length - 1] : undefined;

  return {
    from: from,
    target: target,
    latencyMs: latencyMs,
    ttl: ttl,
    seq: seq,
    peer: peer,
    peerRdns: peerRdnsLast,
    peerASN:
      raws && raws.length > 0 ? raws[raws.length - 1].PeerASN : undefined,
    peerLocation:
      raws && raws.length > 0 ? raws[raws.length - 1].PeerLocation : undefined,
    peerISP:
      raws && raws.length > 0 ? raws[raws.length - 1].PeerISP : undefined,
    peerExactLocation:
      raws && raws.length > 0
        ? raws[raws.length - 1].PeerExactLocation
        : undefined,
    lastHop:
      raws && raws.length > 0 ? raws[raws.length - 1].LastHop : undefined,
  };
}

export type PingRequest = {
  sources: string[];
  targets: string[];
  count?: number;
  intervalMs: number; // how fast to generate icmp echo requests
  pktTimeoutMs: number; // how patient to wait for a icmp reply
  resolver?: string;

  // it is a pattern string for specifying how the agent generates icmp echo request packets
  // example values:
  // 'auto': incrementally increase the ttl from 1, until the destination is reached
  // 'auto(<number)': like 'auto', but explicitly specify the starting ttl
  // 'range(<s>;<e>;<d>)', 'range(<s>;<e>)' specify a range, or a range with step 'd'
  // '<number>', fixed number
  // (omit): agent will automatically determine the ttl, mostly used in pingging rather that tracerouting
  ttl?: string;

  ipInfoProviderName?: string;
};

export function generatePingSampleStream(
  pingReq: PingRequest
): ReadableStream<PingSample> {
  const {
    sources,
    targets,
    count,
    intervalMs,
    pktTimeoutMs,
    ttl,
    ipInfoProviderName,
    resolver,
  } = pingReq;

  const urlParams = new URLSearchParams();
  urlParams.set("from", sources.join(","));
  urlParams.set("targets", targets.join(","));
  if (count !== undefined && count !== null && count > 0) {
    urlParams.set("count", count.toString());
  }
  urlParams.set("intervalMs", intervalMs.toString());
  urlParams.set("pktTimeoutMs", pktTimeoutMs.toString());
  if (resolver) {
    urlParams.set("resolver", resolver);
  }

  if (ttl !== undefined && ttl !== null && ttl !== "") {
    urlParams.set("ttl", ttl);
  }

  if (ipInfoProviderName) {
    urlParams.set("ipInfoProviderName", ipInfoProviderName);
  }

  const headers = new Headers();
  headers.set("Content-Type", "application/json");

  let controlscope: {
    rawStream?: ReadableStream<Uint8Array<ArrayBuffer>> | null;
    sampleStream?: ReadableStream<PingSample> | null;
    reader?: ReadableStreamDefaultReader<PingSample> | null;
    stopped?: boolean;
  } = {};

  return new ReadableStream<PingSample>({
    start(controller) {
      fetch(`${getApiEndpoint()}/ping?${urlParams.toString()}`, {
        method: "GET",
        headers: headers,
      })
        .then((res) => res.body)
        .then((rawStream) => {
          controlscope.rawStream = rawStream;
          return rawStream
            ?.pipeThrough(new TextDecoderStream())
            .pipeThrough(new LineTokenizer())
            .pipeThrough(new JSONLineDecoder())
            .pipeThrough(new PingEventAdapter());
        })
        .then((maybeSampleStream) => {
          controlscope.sampleStream = maybeSampleStream;
          if (maybeSampleStream) {
            const reader = maybeSampleStream.getReader();
            controlscope.reader = reader;
            function push() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  return;
                }
                if (value && !controlscope.stopped) {
                  if (value.lastHop) {
                    console.log(
                      "[dbg] last hop ttl reset to=",
                      value.ttl,
                      value
                    );
                  }
                  controller.enqueue(value);
                }
                push();
              });
            }
            push();
          }
        });
    },
    cancel() {
      console.log("[dbg] cancel stream", sources, targets);
      controlscope.stopped = true;
      controlscope.reader
        ?.cancel()
        .then(() => {
          console.log("[dbg] reader cancelled");
        })
        .catch((err) => {
          console.error("[dbg] failed to cancel reader:", err);
        });
    },
  });
}
